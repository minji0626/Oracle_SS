SELECT 문 : 데이터베이스로부터 저장되어있는 데이터를 검색하는데 사용

전체 컬럼의 데이터 읽기
SELECT empno, ename,job,mgr,hiredate,sal,comm,deptno FROM emp;
SELECT *  FROM emp;

부분 컬럼의 데이터 읽기
SELECT ename,sal FROM emp;

주석
SELECT * FROM emp;
/**/

DUAL:함수 및 계산의 결과를 볼 때 사용할 수 있는 공용(public) 테이블
   사용자 데이터가 있는 테이블에서 유래하지 않은 상수 값
   의사열(pesudo-coumn), 표현식 등의 값을 단 한번만 돌리거나 현재 날짜,
   시각을 알고자 할 때 이용. 일시적인 산술, 날짜 연산 등에 주로 사용

SELECT SYSDATE FROM dual;
SELECT ASCII('A') FROM dual;
SELECT ASCII(0) FROM dual;
SELECT 7 + 10 FROM dual;

연산
select ename,sal from emp;
select ename, sal, sal + 300 from emp;

null값의 정의 : null은 사용할 수 없거나, 할당되지 않았거나, 알 수 없거나, 적용할 수 없는 값 (null은 0이나 공백과 다름)   
SELECT empno,ename,job,comm FROM emp;

산술식의 NULL값 : NULL 값을 포함하는 산술식은  NULL로 계산
SELECT ename, (sal+comm)*12 FROM emp; 

열 ALIAS : 열의 별칭
열 이름 바로 뒤에 나옴. 열 이름과 ALIAS 사이에 선택사항인 AS 키워드가 올 수 있음
알리아스에 큰따옴표를 사용하는 경우
- 대소문자 구별을 원할 때
- 공백 포함시
- _,# 등 특수문자 사용시(_는 ""없이 중간에는 올 수 있으나 맨 앞에 오면 오류 발생)
- 숫자로 시작할 경우 
SELECT sal*12 ASal FROM emp;
SELECt sal*12 AS AsAl FROM emp;
SELECT sal*12 "Annual Salary" FROM emp;

연결 연산자 : 열이나 문자열을 다른 열에 연결, 두개의 세로선(||)으로 나타냄 결과 열로 문자식을 생성
SELECT ename || ' has $' || sal FROM emp;

연결 연산자와 null 값: 문자열에 nulll값을 결합할 경우 결과는 문자열
SELECT ename || comm From emp;

DISTINCT :중복행 삭제
SELECT DISTINCT deptno FROM emp;

[실습 문제]
1. emp 테이블에서 사원번호, 사원 이름, 월급을 출력하시오
2. emp 테이블에서 사원이름과 월급을 출력하는데 컬럼 명은 "이 름" ,  "월 급"으로 바꿔서 출력
3. emp테이블에서 사원 번호, 사원 이름, 월급, 연봉을 구하고 각각 칼럼명은
"사원번호" , "사원이름" "월급" "연봉"
4. emp 테이블의 업무를 중복되지 않게 표시하시오

SELECT empno , ename, sal FROM emp;

SELECT ename AS "이 름" , sal AS "월 급" FROM emp;

SELECT empno "사원번호",  ename "사원이름" , sal  "월급" , (sal*12) "연봉" FROM emp;

SELECT DISTINCT job FROM emp; 

WHERE절 사용 : 조건 체크 결과 행 제한하기
                    // (주의) ALIAS 사용 불가
                     
SELECT * FROM emp WHERE deptno = 10;
SELECT ename, job, deptno FROM emp WHERE ename = 'SMITH';
SELECT * FROM emp WHERE hiredate > '81-12-03' ; 
//81년 12월 3일 이후의 입사자
SELECT * FROM emp WHERE hiredate < '81-12-03';
// 81년 12월 3일 이전의 입사자
SELECT ename, sal, sal*12 ansal FROM emp WHERE  sal*12 > 15000;

SELECT * FROM emp WHERE hiredate != '80-12-17'; 
SELECT * FROM emp WHERE hiredate <> '80-12-17';
SELECT * FROM emp WHERE hiredate ^= '80-12-17';
80년 12월 17일 입사자를 제외한 나머지 사람들 다 불러옴

SELECT * FROM emp WHERE sal > 2000 AND sal <=5000 ;
SELECT * FROM emp WHERE sal >= 800 AND sal <= 3000 ;
특정 구간의 데이터를 불러온다

BETWEEN ... AND ... : 두 값 사이 (지정한 값 포함)
SELECT * FROM emp WHERE sal BETWEEN 800 AND 3000;
SELECT * FROM emp WHERE sal NOT BETWEEN 800 AND 3000;
SELECT * FROM emp WHERE ename BETWEEN 'KING' AND 'SMITH';
SELECT * FROM emp WHERE ename NOT BETWEEN 'KING' AND 'SMITH';

IN : 값 목록 중의 값과 일치
SELECT * FROM emp WHERE sal IN (1300,2450,3000);
SELECT * FROM emp WHERE sal NOT IN (1300,2450,3000);
SELECT ename,mgr,deptno  FROM emp WHERE ename IN ('ALLEN' , 'FORD');
SELECT ename,mgr,deptno  FROM emp WHERE ename NOT IN ('ALLEN' , 'FORD');

[실습 문제]
1. emp 테이블에서 사원번호가 7698인 사원의 이름, 업무, 급여를 출력하시오.
2. emp 테이블에서 사원 이름이 SMITH인 사람의 이름과 월급 부서번호를 구하시오.
3. emp테이블에서 월급이 2500 이상 3500 미만인 사원의 이름, 입사일, 월급을 구하시오.
4. emp 테이블에서 2000에서  3000사이에 포함되지 않는 사원의 이름, 업무, 급여를 출력하세요.

SELECT ename, job, sal FROM emp WHERE empno = '7698';
SELECT ename, sal ,deptno FROM emp WHERE ename = 'SMITH';
SELECT ename, hiredate, sal FROM emp WHERE sal >= 2500 AND sal < 3500 ;
SELECT ename, job, sal FROM emp WHERE sal BETWEEN 2000 AND 3000;

LIKE : 패턴과 일치하는 데이터를 검색
%는 0개 이상의 문자를 나타냄
_는 한 문자를 나타냄

S가 처음, 중간, 끝에 오는 이름을 검색
SELECT * FROM emp WHERE ename LIKE '%S%'; 
SELECT * FROM emp WHERE ename NOT LIKE '%S%';

입사일이 22로 끝나는 사원 정보 구하기
SELECT ename, hiredate FROM emp WHERE hiredate LIKE '%22';

FOR다음에 정해지지 않은 한 문자를 가진 사람을 불러오기
SELECT * FROM emp WHERE ename LIKE 'FOR_';

한 글자 다음의 M, M다음에 없거나 여러개
SELECT * FROM emp WHERE ename LIKE '_M%';


SELECT * FROM emp WHERE ename LIKE'SC\_%' ESCAPE '\';
검색하고자 하는 문자열에 _가 포함되어 있으면 _ 앞에 \를 붙이고 escape \를 명시해준다.
SELECT * FROM emp WHERE ename like '%\%' ESCAPE '\';
검색하고자 하는 문자열에 %가 포함되어 있을 경우

NULL 조건 사용
사원들 중 comm 계약을 안 맺은 사람 구하기
select * from emp where comm is null;
select * from emp where comm is not null;

논리 연산자(AND, OR, NOT)를 사용하여 조건 정의
AND 연산자의 사용 : 구성 요소 조건이 모두 TRUE이면 TRUE를 반환
SELECT empno, ename, job, sal From emp WHERE sal >= 2000 AND job LIKE  '%MAN%'; 
사원 번호, 이름, 업무, 급여를 불러오세요 그러나 급여는 2000이상이고 업무에는 MAN이 들어가야합니다.

OR 연산자의 사용 : 조건 중 하나가 TRUE면 TRUE를 반환
SELECT empno, ename, job, sal FROM emp WHERE sal>=2000 OR job LIKE '%MAN%';
사원 번호, 이름 , 업무, 급여를 출력하세요 급여가 2000이상이거나 업무에 MAN이 들어간다면

NOT 연산자의 사용
SELECT ename, job FROM emp WHERE job NOT IN ('CLERK' , 'SALESMAN');
사원이름과 업무를 출력하세요 그러나 업무가 CLERK, SALESMAN인 사람들은 제외시키세요

[실습 문제]
1. EMP 테이블에서 81년 05월 01일과 81년 12월 03일 사이에 입사한 사원의 이름, 급여, 입사일을 출력하세요
2. EMP 테이블에서 사원 번호가 7566. 7782, 7934인 사원을 제외한 사람들의 사원번호, 이름, 월급을 출력하세요.
3. EMP 테이블에서 급여가 $2,000와 $5,000사이고 부서 번호가 10 또는 30인 사원의 이름과 급여, 부서번호를 출력하세요.
4. EMP 테이블에서 업무가 SALESMAN 또는 MANAGER이면서 급여가 $1,600 , $2,975 , $2,850이 아닌 모든 사원이름, 업무, 급여를 표시하세요.

SELECT ename, sal, hiredate FROM emp  WHERE hiredate BETWEEN '81-05-01' AND '81-12-03';
SELECT empno, ename, sal FROM emp WHERE empno NOT IN (7566 , 7782, 7934);
SELECT ename, sal, deptno FROM emp WHERE (sal >= 2000 AND sal <=5000) AND deptno IN (10, 30); 
SELECT ename, job, sal FROM emp WHERE job IN ('SALESMAN' ,  'MANAGER') AND sal NOT IN (1600, 2975, 2850);


ORDER BY 절 : 정렬
SELECT * FROM emp WHERE deptno = 10 ORDER BY sal ASC;
SELECT * FROM emp WHERE deptno = 10 ORDER BY sal DESC;
SELECT * FROM emp WHERE deptno = 10 ORDER BY sal, ename;
SELECT * FROM emp WHERE deptno = 10 ORDER BY sal ASC , ename DESC; 

내림차순 정렬
SELECT ename, job, deptno, hiredate FROM emp ORDER BY hiredate DESC;

1차 정렬에서 중복값이 있을 경우 2차 정렬 수행
SELECT * FROM emp ORDER BY sal DESC, ename DESC;

날짜 정렬
SELECT ename, job, deptno, hiredate FROM emp ORDER BY hiredate DESC;

열 ALIAS를 기준으로 정렬
SELECT empno, ename, (sal*12) annsal FROM emp ORDER BY annsal;

열의 숫자 위치를 사용하여 정렬
SELECT ename, job, deptno, hiredate FROM emp ORDER BY 3;

테이블에 생성된 순서대로 열 숫자 위치 부여
SELECT * FROM emp ORDER BY 2;

NULL값을 갖고 있는 칼럼을 정렬할 떄
NULLS FIRST 또는 NULLS LAST 키워드를 사용하여 반환된 행 중
NULL 값을 포함하는 행이 정렬 순서상 맨 처으멩 나타나거나 마지막에 나타나도록 지정
SELECT * FROM emp ORDER BY comm NULLS FIRST;
SELECT * FROM emp ORDER BY comm NULLS LAST;

SELECT * FROM emp ORDER BY comm NULLS LAST, ename DESC;
SELECT * FROM emp ORDER BY comm DESC NULLS FIRST;

여러 열을 기준으로 정렬
SELECT ename, deptno, sal FROM emp ORDER BY deptno, sal DESC;

[실습 문제]
1. 사원 번호, 사원 이름, 입사일을 출력하는데 입사일이 빠른 사람순으로정렬하시오.
2. 사원 이름, 급여, 연봉을 구하고 연봉이 많은 순으로 정렬하시오.
3. 10번 또는 20번 부서에서 근무하고 있는 사원의 이름과 부서 번호를 출력하는데 이름을 영문자순으로 표시하시오.
4. 커미션 계약을 맺은 모든 사원의 이름, 급여, 커미션을 출력하는데 커미션을 기준으로 내림차순 정렬하시오.

SELECT empno, ename, hiredate FROM emp ORDER BY hiredate ASC; 
SELECT ename, sal, sal*12 FROM emp ORDER by sal*12 DESC;
SELECT ename, deptno FROM emp WHERE deptno IN(10 , 20) ORDER BY ename ASC; 
SELECT ename, sal, comm FROM emp WHERE comm IS NOT null ORDER BY comm DESC;

함수

문자 함수
대소문자 조작 함수 - LOWER, UPPER, INITCAP
SELECT LOWER('HELLO') FROM dual;
SELECT LOWER(ename) FROM emp;

SELECT UPPER ('hello')  FROM dual;

문장의 첫 글자를 대문자로 변경, 그 다음은 소문자
SELECT INITCAP('hello wORLD') FROM dual;

문자 조작 함수
CONCAT(문자열1, 문자열2) : 문자열 1과 문자열2를 연결하여 하나의 문자열로 반환
SELECT CONCAT('Hello' , 'World') FROM dual;
SELECT CONCAT (ename , job)  FROM emp;

SUBSTR(대상문자열, 인덱스) : 대상문자열에서 지정한 인덱스부터 문자열을 추출 [주의] 인덱스 1부터 시작
SELECT SUBSTR ('Hello World' , 3) FROM dual;
SELECT SUBSTR ('Hello World' ,3,3) FROM dual; -- 인덱스 3부터 문자 3개 추출
SELECT SUBSTR ('Hello World',-3) FROM dual;  -- 뒤에서 3번째부터 끝까지 추출
SELECT SUBSTR ('Hello World',-3,2) FROM dual; -- 뒤에서 3번째부터 문자 2개 추출

LENGTH(대상문자열) : 문자열의 개수
SELECT LENGTH ('Hello World') FROM dual;
SELECT LENGTH (ename)   FROM emp;

INSTR (대상문자열, 검색 문자) : 검색문자의 위치값 검색
SELECT INSTR('Hello World' , 'e' ) FROM dual;
검색 문자가 없을 경우 0 반환
SELECT INSTR('Hello World','E') FROM dual;

SELECT INSTR ('Hello World','o') FROM dual;
SELECT INSTR ('Hello World','o',6) FROM dual;
SELECT INSTR ('Hello World','o',1,2) FROM dual;

LPAD(대상문자열, 총길이, 문자) : 지정한 길에 문자열을 출력하는데 공백은 왼쪽에 지정한 문자로 채움
SELECT LPAD ('HELLO', 10 , '*' ) FROM dual;

RPAD(대상문자열, 총길이, 문자) : 지정한 길에 문자열을 출력하는데 공백은 오른쪽에 지정한 문자로 채움
SELECT RPAD ('HELLO', 10 , '*' ) FROM dual;


TRIM :  문자열에서 공백이나 특정 문자를 제거한 다음에 다음 값을 반환
방향 : 왼쪽 -> LEADING ,  오른쪽 -> TRAILING , 양쪽 -> BOTH <- DEFAULT
SELECT TRIM (LEADING 'h' FROM 'habchh') FROM dual;
SELECT TRIM (TRAILING 'h' FROM 'habchh') FROM dual;
SELECT TRIM (BOTH 'h' FROM 'hahchh') FROM dual;

LTRIM : 문자열의 왼쪽에서 공백이나 특정 문자를 제거한 다음 값을 반환
RTRIM : 문자열의 오른쪽에서 공백이나 특정 문자를 제거한 다음 값을 반환

REPLACE (대상문자열,OLD,NEW) : 대상문자열에서 OLD 문자를 NEW 문자로 대체
SELECT REPLACE ('010.1234.5678' , '.' , '-') FROM dual;

함수 중첩
SELECT ename , LOWER(SUBSTR(ename,1,3)) FROM emp;

[실습 문제]
1. EMP 테이블에서 업무의 첫글자는 대문자 나머지는 소문자로 출력하시오.
2. EMP 테이블에서 사원 이름중 A가 포함된 사원이름을 구하고 그 이름 중 앞에서 3글자만 추출하여 출력하시오.
3. EMP 테이블에서 이름의 3번째가 문자가 A인 모든 사원의 이름을 표시하시오.
4. EMP 테이블에서 이름이 J, A, M으로 시작하는 모든 사원의 이름[첫 글자는 대문자로 나머지는 소문자] 및 이름의 길이를 표시하시오.
[열 레이블은 name, length로 표시]

SELECT INITCAP (job) FROM emp;

SELECT SUBSTR ( ename, 1 , 3) FROM emp WHERE ename LIKE '%A%';

SELECT ename FROM emp WHERE ename LIKE '__A%' ;
SELECT ename FROM emp WHERE SUBSTR( name, 3, 1) = 'A' ;

SELECT INITCAP (ename) name, LENGTH (ename) length FROM emp WHERE (ename LIKE 'J%' OR ename LIKE 'A%' OR ename LIKE 'M%');
SELECT INITCAP (ename) name, LENGTH (ename) length FROM emp WHERE SUBSTR ( ename , 1 , 1) IN( 'J' , 'A', 'M') ;


숫자 함수

CEIL (실수) : 올림 처리한 정수값을 반환
SELECT CEIL(1.4) FROM dual;

FLOOR(실수) : 버림 처리한 정수 값을 반환
SELECT FLOOR (1.7) FROM dual;

ROUND (대상숫자, 지정자릿수) : 반올림
SELECT ROUND (45.926 , 2) FROM dual;
SELECT ROUND (45.926) FROM dual;

SELECT empno , ename , sal , ROUND(sal * 1.15) "New Salary" , ROUND(sal* 1.15) - sal "Increase" FROM emp;

TRUNC (대상숫자 , 지정자리수) : 절삭
SELECT TRUNC (45.926 , 2 ) FROM dual;

MOD ( 대상숫자, 나눌숫자) : 나머지값
SELECT MOD (17,2) FROM dual;

날짜 함수

날짜에 산술 연산자 사용
SELECT ename , TRUNC((SYSDATE - hiredate) / 7) AS weeks FROM emp WHERE deptno = 10;

MONTHS_BETWEEN(날짜1, 날짜2) :  두 날짜 간의 개월 수
SELECT MONTHS_BETWEEN ('2012-03-23','2010-01-23') FROM dual;
SELECT ename, TRUNC ( MONTHS_BETWEEN (SYSDATE , hiredate)) months_worked FROM emp ORDER BY months_worked;

ADD_MONTHS : 특정 날짜의 월에 정수를 더한 다음 해당 날짜를 반환하는 함수
select add_months('2022-01-01',8) from dual;

NEXT_DAY : 지정된 요일의 다음 날짜
SELECT NEXT_DAY ('2024-03-12','월요일') FROM dual;

1(일요일) - 7(토요일)
SELECT NEXT_DAY ('2024-03-12',2) FROM dual;

LAST_DAY : 월의 마지막 날
SELECT LAST_DAY ('2012-11-07' ) FROM dual;

EXTRACT : 날짜 정보에서 특정한 연도, 월, 일, 시간, 분, 초 등을 추출
SELECT EXTRACT (YEAR FROM SYSDATE), EXTRACT (MONTH FROM SYSDATE) , EXTRACT(DAY FROM SYSDATE) FROM dual;

[실습 문제]
1. EMP 테이블에서 모든 사원의 이름과 급여를 표시하세요. 급여는 15자 길이로 왼쪽에 $ 기호가 채워진 형식으로 표기하고
열 레이블은 SALARY로 지정하세요.
2. EMP 테이블에서 모든 사원의 이름, 업무, 급여, 부서 번호를 출력하세요. 
부서 번호는 오름차순 정렬을 하고 사원의 이름은 길이 :  10 , 빈칸은 *로 표시하세요.
3. 오늘부터 이번 달의 마지막 날 까지의 남은 날 수를 구하세요.
4. EMP 테이블에서 각 사원에 대해 사원 번호, 이름, 급여 및 15% 인상된 급여를 정수(반올림)로 표시하세요.
인상된 급여열의 레이블은 NEW SALARY로 지정하세요.

SELECT ename, LPAD (sal,15,'$') "Salary"  FROM emp;
SELECT RPAD (ename ,10,'*'), job, sal, deptno FROM emp ORDER BY deptno ASC ;
SELECT (LAST_DAY(SYSDATE) - SYSDATE ) FROM dual;
SELECT empno, ename, sal, ROUND(sal *1.15) "New Salary" FROM emp;

변환 함수

TO_CHAR : 숫자 => 문자 ,  날짜 => 문자
TO_NUMBER : 문자 => 숫자
TO_DATE : 문자 => 날짜

TO_CHAR : 숫자가 문자 , 날짜가 문자
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD') FROM dual;
SELECT TO_CHAR (SYSDATE, 'YYYY-MM-DD PM HH:MI:SS') FROM dual;

실제 자리수와 일치
SELECT TO_CHAR (1234 , 9999) FROM dual;
SELECT TO_CHAR (1234 , '9999') FROM dual;
SELECT TO_CHAR (1234 , 0000) FROM dual;

자리수가 모자람 => ####
SELECT TO_CHAR (1234 , 999) FROM dual;
SELECT TO_CHAR (1234 , '999') FROM dual;
SELECT TO_CHAR (1234 , '000') FROM dual;

실제 자리수 보다 많은 자리수 지정
SELECT TO_CHAR (1234 , 99999) FROM dual;
SELECT TO_CHAR (1234 , '99999') FROM dual;
SELECT TO_CHAR (1234 , '00000') FROM dual;

소수점 자리 지정
SELECT TO_CHAR (1234, 9999.99) FROM dual;
SELECT TO_CHAR (1234, '9999.99') FROM dual;
SELECT TO_CHAR (1234, '0000.00 ') FROM dual;

반올림해서 소숫점 둘째자리까지 표시
SELECT TO_CHAR (25.897, '99.99') FROM dual;

인상된 급여를 소수점 첫째자리까지 표시
SELECT TO_CHAR (SAL*1.15, '9,999.9') FROM EMP;

통화 표시
SELECT TO_CHAR(1234, '$0000') FROM dual;
SELECT TO_CHAR(1234, '$9999') FROM dual;

지역 통화 표시
SELECT TO_CHAR(1234, 'L9999') FROM dual;

TO_DATE : 문자 -> 날짜
SELECT TO_DATE ('24-03-12','YYYY-MM-DD') FROM dual;
포맷 형식 생략 가능
SELECT TO_DATE ('24-03-12') FROM dual;

TO_NUMBER : 문자 -> 숫자
SELECT TO_NUMBER('100' , 999) FROM dual;


[숙제]
1) emp 테이블의 사원명과 업무를 쉼표(,)로 연결해서 표시하고 컬럼명은 Employee and Job으로 표시하시오.
2) 부서번호 30(deptno)에서 근무하며 월 2,000달러 이하를 받는 81년 5월 1일 이전에 입사한 사원의 이름, 급여, 부서번호, 입사일을 출력하시오.
3) emp 테이블에서 이름에 A와 E가 있는 모든 사원의 이름을 표시하시오.
4) emp 테이블에서 사원이름 중 S가 포함되지 않은 사람들 중 부서번호가 20인 사원들의 이름과 부서번호를 출력하시오.
5) emp 테이블에서 관리자(mgr)가 없는 모든 사원의 이름과 업무를 표시하시오.
6) emp 테이블에서 커미션 항목이 입력된 사원들의 이름과 급여, 커미션을 구하시오.
7) 이름의 글자수가 6자 이상인 사원의 이름을 소문자로 이름만 출력하시오.
8) 이름의 글자수가 6자이상인 사람의 이름을 앞에서 3자만 구하여 소문자로 출력하시오.
9) 각 사원의 이름을 표시하고 근무 달 수(입사일로부터 현재까지의 달 수)를 계산하여 열레이블을 MONTHS_WORKED로 지정하십시오. 결과는 정수로 반올림하여 표시하고 근무 달 수를 기준으로 오름차순으로 정렬하시오.
10) emp 테이블에서 이름(소문자로 표시), 업무, 근무연차를 출력하시오.

1) SELECT ename || ', ' || job AS "Employee and Job" FROM emp;
2) SELECT ename, sal, deptno, hiredate FROM emp WHERE deptno = 30 AND sal<= 2000 AND hiredate < '81-5-1' ; 
3) SELECT ename FROM emp WHERE ename LIKE '%A%' AND ename LIKE '%E%';
4) SELECT ename, deptno FROM emp WHERE ename NOT LIKE '%S%' AND deptno = 20;
5) SELECT ename, job FROM emp WHERE mgr IS NOT null;
6) SELECT ename, sal, comm FROM emp WHERE comm IS NOT null;
7) SELECT LOWER(ename) FROM emp WHERE LENGTH(ename) >= 6;
8) SELECT SUBSTR (LOWER(ename) , 1 , 3) FROM emp WHERE LENGTH(ename) >= 6 ;
9) SELECT ename, ROUND( MONTHS_BETWEEN (SYSDATE , hiredate) ) AS MONTHS_WORKED FROM emp  ORDER BY MONTHS_WORKED ASC ;
10) SELECT LOWER(ename) , job, TRUNC ( (SYSDATE - hiredate ) / 365 ) AS YEARS_WORKED FROM emp;

일반 함수

NVL( value1 , value2) : value1이 null이면 value2를 쓴다. value1과 value2의 자료형이 일치
SELECT ename, sal, comm , (sal + NVL (comm , 0)) * 12 FROM emp;
SELECT ename, NVL ( TO_CHAR(comm)  , 'No Commission')  AS "COMM" FROM emp;

NVL2 ( value1 , value2, value3) : value1이 null인지 평가. null이면 value3, null이 아니면 value2 자료형이 일치하지 않아도 된다.
SELECT NVL2(comm , 'Commission' , 'No  Commision') FROM emp;

NULLIF (value1, value2) :  두 개의 값이 일치하면 NULL ,  두 개의 값이 일치하지 않으면 value1
SELECT NULLIF (LENGTH(ename) , LENGTH( job )) "NULLIF" FROM emp;

COALESCE (value1, valu2, value3 ...) : NULL값이 아닌 값을 사용한다. (자료형 일치)
SELECT comm, sal, COALESCE(comm, sal, 0) FROM emp;
SELECT comm, mgr, sal, COALESCE ( comm, mgr, sal) FROM emp;

CASE 칼럼  WHEN 비교값 THEN 결과값
               WHEN           THEN
               WHEN           THEN
               (ELSE 결과값)
      END

SELECT ename, sal, job, CASE job WHEN 'SALESMAN' THEN sal * 0.1
                                             WHEN 'MANAGER' THEN sal * 0.2
                                             WHEN 'ANALYST' THEN sal * 0.3
                                             ELSE sal * 0.4
                              END "Bonus" FROM emp;

SELECT ename, sal, job, CASE WHEN sal >= 4000 AND sal <= 5000 THEN 'A'
                                       WHEN sal >= 3000 AND sal < 4000 THEN 'B'
                                       WHEN sal >= 2000 AND sal < 3000 THEN 'C'
                                       WHEN sal >= 1000 AND sal < 2000 THEN 'D'
                                       ELSE 'F'
                        END "Grade"
               FROM emp;

DECODE : = 비교만 그낭함, 오리클 전용
         DECODE (칼럼, 비교값, 반환값,
                              비교값, 반환값,
                              비교값, 반환값,
                              반환값)
SELECT ename, sal, job,
         DECODE ( job , 'SALESMAN' , sal * 0.1 ,
                              'MANAGER' , sal * 0.2 ,
                              'ANALYST' , sal * 0.3 ,
                               sal * 0.4 )
                  "Bonus"
FROM emp;

SELECT ename, sal, job,
            DECODE ( TRUNC ( sal / 1000) , 5, 'A',
                                                      4 , 'A',
                                                      3 , 'B',
                                                      2 , 'C',
                                                      1 , 'D',
                                                      'F' ) "Grade"
   FROM emp;

[실습 문제]
1. EMP 테이블에서 사원 이름, 월급, 월급과 커미션을 더한 값을 컬럼명 실급여라고 해서 출력하세요.
   단 , NULL 값은 나타나지 않게 작성하세요.
2. EMP 테이블에서 월급과 커미션을 합친 금액이 2000 이상인 급여를 받는 사원의 이름, 업무, 월급, 커미션, 고용날짜를 출력하세요.
   단, 고용 날짜는 1980 - 12 - 17 형태로 출력하세요.

SELECT ename, sal,  ( sal + NVL ( comm , 0 ) ) AS "실급여" FROM emp;
SELECT ename, job, sal, comm, TO_CHAR ( hiredate , 'YYYY-MM-DD') "hiredate"FROM emp WHERE ( sal + NVL ( comm , 0 ) ) >= 2000;

그룹 함수 : 행 집합 연산을 수행하여 그룹별로 하나의 결과를 산출

AVG() : NULL을 제외한 모든 값들의 평균을 반환. NULL값은 평균 계산에서 무시됨
SELECT AVG(sal)   FROM emp;
SELECT ROUND ( AVG(sal)) FROM emp;

COUNT() : NULL을 제외한 값을 가진 모든 레코드의 수를 반환. COUNT(*) 형식을 사용하면 NULL도 계산에 포함
SELECT COUNT (empno) FROM emp;
SELECT COUNT (comm) FROM emp;
SELECT COUNT(*) FROM emp;

MAX () : 레코드 내에 있는 여러 값 중 가장 큰 값을 반환
SELECT MAX (sal) FROM emp;
SELECT MAX (ename) FROM emp;
SELECT MAX (hiredate) FROM emp;

MIN () : 레코드 내에 있는 여러 값 중 가장 작은 값을 반환
SELECT MIN(sal) FROM emp;
SELECT MIN (ename) FROM emp;
SELECT MIN(hiredate) FROM emp;

SUM() : 레코드들이 포함하고 있는 모든 값을 더하여 반환
SELECT SUM(sal) FROM emp;

SELECT MAX(sal) 최대 ,MIN(sal) 최소 , ROUND(AVG(sal)) 평균 , SUM(sal) 합계 FROM emp;
SELECT MAX(sal), MIN (sal), ROUND(AVG(sal)) , SUM(sal) FROM emp WHERE deptno = 10;
SELECT COUNT(*) FROM emp WHERE deptno = 20;

GROUP BY : SELECT절에 집합함수 적용시 개별 컬럼을 지정할 수 없음.
                 개별 컬럼을 지정할 경우에는 반드시 GROUP BY 절에 지정된 컬럼만 가능하다.
                 
SELECT deptno, MAX(sal) FROM emp GROUP BY deptno;
SELECT deptno, MAX(sal) FROM emp GROUP BY deptno ORDER BY deptno;

부서별로 사원 수 구하기
SELECT deptno , COUNT(empno) FROM emp GROUP BY deptno ORDER BY deptno;
SELECT * FROM emp;
SELECT COUNT(empno) ,job FROM emp GROUP BY job;

다중 열에서 GROUP BY 절 사용하기
SELECT deptno , job, SUM(sal) FROM emp GROUP BY deptno, job ORDER BY deptno;

그룹함수를 사용한 잘못된 Query

HAVING : 그룹함수를 이용해서 조건 체크할 때 사용 알리아스 사용 불가능
[오류 발생]
SELECT deptno , AVG(sal) FROM emp WHERE AVG(sal) >= 2000 GROUP BY deptno; -- WHERE 에 그룹 함수를 이용해서 조건을 체크하면 오류 발생
[정상 구문]
SELECT deptno, AVG(sal) FROM emp GROUP BY deptno HAVING AVG(sal) >= 2000;
               
부서별로 최대 급여를 구하는데 3000을 초과한 최대 급여를 구하세요.
SELECT deptno, MAX(sal) FROM emp GROUP BY deptno HAVING MAX(sal) > 3000 ;

그룹 함수 중첩 
SELECT MAX(AVG(sal)) FROM emp GROUP BY deptno;

분기별로 입사한 사원의 수 
SELECT TO_CHAR (hiredate , 'Q') "분기" , COUNT(ename) "사원 수" FROM emp GROUP BY TO_CHAR (hiredate , 'Q') ORDER BY "분기";


[실습 문제]
1. 모든 사원의 급여 최고액, 최저액, 총액 및 평균액을 표시하시오.
   레이블을 각각 MAXIMUM,MINIMUM,SUM,AVERAGE로 지정하고
   결과를 정수로 반올림하고 세 자리 단위로 ,를 명시하세요.
2. 급여와 커미션을 더한 금액의 최고, 최저, 평균 금액을 구하시오.
   평균 금액은 소수점 첫째 자리까지 표시하시오.
3. 업무와 업무가 동일한 사원의 수를 표시하세요.
   업무별 사원 수를 구하세요.
4. 30번 부서의 사원 수를 구하세요.
부서 번호 명시 하지 않음
SELECT COUNT(*) FROM emp WHERE deptno=30;
부서 번호 명시함
SELECT deptno, COUNT(*) FROM emp WHERE deptno = 30 GROUP BY deptno;
5. 업무별 최고 월급을 구하고 업무, 최고 월급을 출력하세요.
6. 20번 부서의 급여 합계를 구하고 급여 합계 금액을 출력하세요.
7. 부서별로 지급되는 총 월급에서 금액이 9000이상을 받는 사원들의 부서번호, 총월급을 출력하세요.
8. 업무별로 사번이 제일 늦은 사원을 구하고 그 결과 내에서 사번이 79로 시작하는 결과만 보여주세요.
9. 업무별 총 월급을 출력하는 업무가'MANAGER'인 사원들은 제외하고 총 월급이 5000 보다 많은 업무와 총 월급만 출력하세요.
10. 업무별로 사원의 수가 4명 이상인 업무와 인원 수를 출력하세요.

SELECT TO_CHAR(MAX(sal), '9,999') "Maximum" , TO_CHAR(MIN(sal), '9,999') "Minimum" , TO_CHAR(SUM(sal) , '99,999') "Sum" , TO_CHAR (ROUND(AVG(sal)), '9,999') "Average" FROM emp;   
SELECT MAX( sal + NVL ( comm , 0 )) "Max", MIN( sal + NVL ( comm , 0 )) "Min", ROUND(AVG( sal + NVL ( comm , 0 )) , 1) "Avg" FROM emp;
SELECT COUNT(ename), job FROM emp GROUP BY job ORDER BY job;
SELECT COUNT(ename) FROM emp WHERE deptno = 30;
SELECT job, MAX(sal) FROM emp GROUP BY job;
SELECT SUM(sal) FROM emp WHERE deptno = 20;
SELECT SUM(sal) "총 월급", deptno FROM emp GROUP BY deptno HAVING SUM(sal) >= 9000;
SELECT job, MAX(empno) FROM emp GROUP BY job  HAVING MAX(empno) LIKE '79%';
SELECT job, MAX(empno) FROM emp WHERE empno LIKE '79%' GROUP BY job;
SELECT job , SUM(sal) FROM emp GROUP BY job HAVING job != 'MANAGER' AND SUM(sal) > 5000 ;
SELECT job , COUNT(empno) FROM emp GROUP BY job HAVING COUNT(*) >= 4;

분석 함수
RANK () : 순위를 표현할 떄 사용하는 함수
RANK(조건값) WITHIN GROUP (ORDER BY 조건값 컬럼명) : 특정 데이터의 순위 확인하기
[주의] RANK 뒤에 나오는 데이터와 ORDER BY 뒤에 나오는 데이터는 같은 걸럼이어야 한다.

SELECT RANK('SMITH') WITHIN GROUP (ORDER BY ename) "RANK" FROM emp;

RANK() OVER (ORDER BY 컬럼명) : 전체 순위
사원들의 empno, ename, sal, 급여 순위를 출력
SELECT empno, ename sal, RANK() OVER(ORDER BY sal DESC) "급여 순위" FROM emp;

10번 부서에 속한 직원들의 사번과 이름, 급여, 해당 부서 내의 급여 순위를 출력하세요.
SELECT ename, sal, RANK() OVER(ORDER BY sal DESC)"급여 순위" FROM emp WHERE deptno = 10;

emp 테이블에서 조회하여 사번, 이름, 급여, 부서번호, 부서별 급여 순위를 출력
SELECT empno, ename, sal, deptno, RANK() OVER (PARTITION BY deptno ORDER BY sal DESC) "급여 순위" FROM emp;
emp 테이블에서 같은 부서내의 job 별로 급여 순위를 출력 empno, ename, sal, deptno, job 을 출력하세요
SELECT empno, ename, sal, deptno,job, RANK() OVER (PARTITION BY deptno, job ORDER BY sal DESC) "급여 순위" FROM emp;



